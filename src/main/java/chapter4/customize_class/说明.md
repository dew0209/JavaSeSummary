自定义类

```xml
在Java中，最简单的类定义形式为：
class ClassName{
	field1
	field2
	...
	construct1
	construct2
	...
	method1
	method2
}
在一个源文件中，只能有一个公共类，但可以有任意数目的非公共类。
将程序中包含main方法的类名提供字节码解释器，以便启动这个程序
注：在命令行中运行时，键入以下命令：java TestCustomize.java，并没有显式的编译Employee.java。然而，当TestCustomize.java使用了Employee类时会自动查找名为Employee.class的文件。如果没有找到这个文件，就会自动搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有的Employee.class文件版本新，java编译器也会自动地重新编译这个文件。
```

构造器

```xml
构造器与类同名
每个类可以有一个以上的构造器
构造器可以有0个，1个或者多个参数
构造器没有返回值
构造器总是伴随着new操作一起调用
```

隐式参数与显式参数

```xml
/**
* 调用将执行下列指令
* double raise = number007.salary * byPercent / 100;
* number007.salary += raise;
*/
number007.raiseSalary(5);

raiseSalary方法有两个参数。第一个参数称为隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。[有些人把隐式参数称为方法调用的目标或接收者]
可以看到，显式参数是明显地列在方法声明中的，例如double byPercent。隐式参数没有出现在方法声明中。在每一个方法中，关键字this表示隐式参数。如果需要，可以用下列方式编写raiseSalary方法：
public void raiseSalary(double byPercent){
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
```

封装的优点

```xml
在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：
一个私有的数据域
一个公有的域数据访问器方法
一个公有的域更改器方法
这样做比提供一个简单的共有数据域复杂，但是却有着好处：
1.可以改变内部实现，除了该类的方法之外，不会影响其它代码。[改变方法的内部实现，程序的其它部分完全不可见]
2.更改器方法可以执行错误检查
注意：不要编写返回引用可变对象的访问器方法。如果该对象有更改器方法，会破坏封装性。如果需要返回一个可变对象的引用，应该返回其克隆的新对象。
```

基础类的访问权限

```xml
一个方法可以访问所属类的所有对象的私有数据
Employee类的方法可以访问Employee类的任何一个对象的私有域
例如：
class Employee{
	...
	public boolean equals(Employee other){
		return name.equals(other.name);
	}
}
```

私有方法

```xml
绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为搜有的。有时，可能希望将一个计算代码划分成若干个独立的辅助方法。通常，这些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序。最好将这样的方法设计为private的。
在Java中，为了实现一个私有的方法，只需要将关键字public改为private即可。
```

final实例域

```xml
可以将实例域定义为final。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域将被设置，并且在后面的操作中，不能够再对它进行修改。
final大多用于基本类型域或不可变类的域(如果类中的每个方法都不会改变其对象，这种类就是不可变的类)。

对于可变的类，使用final修饰符可能会让人产生混乱。[final关键字只是表示存储在evaluations变量中对象的引用不会再指示其它StringBuilder对象，但是这个对象可以更改]
```

静态域

```xml
如果将域定义为static，每个类中只有一个这样的域。而每个对象对于所有的实例域却都有着自己的一份拷贝。
class Employee{
	private static int nextId = 1;
	private int id;
	...
}
每个雇员对象都有一个自己的id域，但这个类的所有实例域将共享nextId域。换句话说，即使存在100个Employee类的对象，则有100个实例域id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。
```

静态常量

```xml
静态变量使用得比较少，但是静态常量却使用得比较多。例如：Math类中的PI
public static final double PI = 3.1415926...;
如果static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有它自己的一份拷贝。
前面曾说，由于每个类的对象都可以对公有域进行修改，所以，最好不要将域设计为public。然而，公有常量（final域）却没问题。因为被声明为final，所以，不允许再将其它同类型的值赋予给它。
```

静态方法

```xml
静态方法是一种不能向对象施加操作的方法。[换句话说，没有隐式的参数]
在下面两种情况下需要使用静态方法：
	1.一个方法不需要访问对象的状态，其所需参数都是通过显式参数提供。
	2.一个方法只需要访问类的静态域
```

工厂方法

```xml
使用静态工厂方法来构建对象
```

